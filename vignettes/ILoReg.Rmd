---
title: "ILoReg package manual"
author: "Johannes Smolander"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{ILoReg package manual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}
---

<style>
body {
text-align: justify}
</style>


```{r knitr-options, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
opts_chunk$set(fig.align = 'center', fig.width = 6, fig.height = 5, dev = 'png')
```


# Introduction
`ILoReg` is a tool for high-resolution *de novo* cell population identification from single-cell RNA-seq (scRNA-seq) data. High-resolution refers to the ability of `ILoReg` to identify subpopulations with subtle transcriptomic differences. In our study [1], we showed that `ILoReg` identitied, by both unsupervised clustering and visually, immune cell populations that other scRNA-seq data analysis pipelines had difficulties to find.

The figure below illustrates the workflows of `ILoReg` and a conventional pipeline that applies feature selection prior to dimensionality reduction by principal component analysis (PCA), e.g. Seurat.

![*Figure: Analysis workflows of `ILoReg` and a feature-selection based approach.*](figure.png){width=100%}

In contrast to most scRNA-seq data analysis pipelines, `ILoReg` does not reduce the dimensionality of the gene expression matrix by feature selection. Instead, it performs probabilistic feature extraction, in which the **iterative clustering projection (ICP)** clustering algorithm is run $L$ times, yielding $L$ different $N \times k$ -dimensional probability matrices that contain probabilities of each of the $N$ cells belonging to the $k$ clusters. ICP is a new clustering algorithm that iteratively seeks a clustering with $k$ clusters that maximizes the adjusted Rand index (ARI) between the clustering $C$ and its projection $C'$ by L1-regularized logistic regression: 
$$\displaystyle \arg \max_C ARI(C,C')$$ 
The $L$ probability matrices are then merged into a joint probability matrix and subsequently transformed by principal component analysis (PCA) into a lower dimensional ($N \times p$) matrix (consensus matrix). The final clustering step is performed using hierarhical clustering by the Ward's method, after which the user can efficiently (~1 s with 3,000 cells) extract a clustering with $K$ consensus clusters. Two-dimensional visualization is supported using two popular nonlinear dimensionality reduction methods: *t*-distributed stochastic neighbor embedding (t-SNE) and uniform manifold approximation and projection (UMAP). Additionally, ILoReg provides user-friendly functions that enable identification of differentially expressed (DE) genes and visualization of gene expression.


# Installation

The latest version of `ILoReg` can be downloaded from GitHub and installed by executing the following command in the R console.


```{r eval = FALSE}
devtools::install_github("elolab/ILoReg")
```


# Example: Peripheral Blood Mononuclear Cells

In the following, we go through the different steps of `ILoReg`'s workflow and demonstrate it using a peripheral blood mononuclear cell (PBMC) dataset. The toy dataset included in the `ILoReg` R package (`pbmc3k_500`) contains 500 cells that have been downsampled from the pbmc3k dataset [2]. The preprocessing was rerun with a newer reference genome (GRCh38.p12) and Cell Ranger v2.2.0 [3].


## Setup a SingleCellExperiment object and prepare it for ILoReg analysis

The only required input for `ILoReg` is a gene expression matrix that has been normalized for the library size, with genes/features in rows and cells/samples in columns. The input can be of `matrix`, `data.frame` or `dgCMatrix` class, which is then transformed into a sparse object of `dgCMatrix` class. Please note that the method has been designed to work with **sparse data**, i.e. with a high proportion of zero values. If, for example, the features of your dataset have been standardized, the run time and the memory usage of `ILoReg` will likely be much higher.



```{r}
suppressMessages(library(ILoReg))
suppressMessages(library(SingleCellExperiment))
suppressMessages(library(cowplot))
# The dataset was normalized using the LogNormalize method from the Seurat R package.
sce <- SingleCellExperiment(assays = list(logcounts = pbmc3k_500))
sce <- PrepareILoReg(sce)
```


## Run the ICP clustering algorithm $L$ times

Running ICP $L$ times in parallel is the most computationally demanding part of the workflow.

In the following, we give a brief summary of the parameters.

* $k$: The number of initial clusters in ICP. The default is $15$. Along with decreasing $d$, increasing $k$ provides the most straightforward way to increase the diversity of the outcome, i.e. more subpopulations with subtle differences are formed.
* $d$: A real number greater than $0$ and smaller than $1$ that determines how many cells $n$ are down- or oversampled from each cluster into the training data ($n= \lceil Nd/k \rceil$), where $N$ is the total number of cells. The default is $0.3$. Decreasing $d$ below $0.2$ is not recommended due to the increased risk of ICP becoming unstable ($k$ starts to decrease during the iteration). In contrast, increasing $d$ above 0.3 will generate more dissimilar ICP runs. This will in turn decrease the heterogeneity of the outcome due to the cluster probabilities that are used in PCA becoming less correlated.
* $C$: A positive real number that rules the trade-off between correct classification and regularization: $$\displaystyle \min_w {\Vert w \Vert}_1 + C \sum_{i=1}^{n} \log (1+ e^{-y_i w^T w})$$ The default is $0.3$. Decreasing $C$ increases the stringency of the L1-regularized feature selection, i.e. less genes are selected into the logistic regression model. With a lower $C$ the outcome will be determined by fewer genes.
* $r$: A positive integer that denotes the maximum number of reiterations performed until the ICP algorithm stops. The default is $5$.
* $L$: The number of ICP runs. The default is $200$. 
* $type$: "L1" or "L2". "L2" denotes L2-regularization (ridge regression), which was not investigated in our study. The default is "L1" (lasso regresssion).
* $threads$: The number of threads to use in parallel computing. The default is $0$: use all available threads but one. The parallelization can be disabled with $threads=1$. 


```{r eval = TRUE}
# ICP is stochastic. To obtain reproducible results, use set.seed().
set.seed(1)
# Run ICP L times. This is  the slowest step of the workflow and parallel processing can be used to greatly speed it up.
sce <- RunParallelICP(object = sce, k = 15,
                      d = 0.3, L = 30, 
                      r = 5, C = 0.3, 
                      reg.type = "L1", threads = 0)
# At this point, saving the results is recommended.
saveRDS(sce,file = "~/pbmc3k_500_iloreg.rds")
```


## Quality control

Next, we consider two quality control measures of ICP that can aid detecting issues with the `ILoReg` analysis.

1. The projection accuracy of ICP that denotes ARI between the clustering and its projection by logistic regression at the final epoch of ICP. A projection accuracy $1$ would mean the classifier was able to predict the cluster membership of all cells correctly. As a general guideline, the projection accuracy of ICP should be on average above $0.5$. A higher accuracy can be achieved using lower values of $k$, $C$ and higher values of $d$ and $r$.

2. The average similarity between different ICP runs, measured by ARI. Since the $L$ probability matrices are merged and transformed into a lower dimensionality by PCA, i.e. linearly transforming a set of correlated variables into a smaller set of uncorrelated variables, some degree of correlation among the probabilities across different ICP runs (i.e. similarity among the ICP runs) is required to identify cell populations. In general, a higher $d$ leads to a lower similarity and a smaller $k$ to a higher similarity.

```{r, fig.height=4, fig.width=9, out.width = '100%',fig.align = "center"}
# Draw violin plots of the projection accuracy of ICP, the number of epochs and the average similarity between ICP runs.
# Each data point represents a single ICP run.
VisualizeQC(sce,return.plot = F)
```


## PCA transformation of the joint probability matrix

The $L$ probability matrices are merged into a joint probability matrix, which is then transformed into a lower dimensionality by PCA. Before applying PCA, the user can optionally filter out ICP runs that achieved lower terminal projection accuracies or scale the cluster probabilities to unit-variance.

```{r}
sce <- RunPCA(sce,p=50,scale = FALSE,threshold = 0)
```


**Optional**: PCA requires the user to specify the number of principal components, for which we selected the default value $p=50$. To aid decision making, the elbow plot is commonly used to seek a point of inflection, of which proximity the user selects $p$. In this case the point would be close to $p=10$.

```{r, fig.height=5, fig.width=7, out.width = '100%',fig.align = "center"}
PCAElbowPlot(sce)
```


## Nonlinear dimensionality reduction

To visualize the data in a two-dimensional space, nonlinear dimensionality reduction is performed using t-SNE or UMAP. The input data for this step is the $N \times p$ -dimensional consensus matrix.

```{r}
sce <- RunUMAP(sce)
sce <- RunTSNE(sce,perplexity=30)
```


## Gene expression visualization

Visualize the t-SNE and UMAP transformations using the `GeneScatterPlot` function, highlighting expression levels of *CD3D* (T cells), *CD79A* (B cells), *CST3* (monocytes, dendritic cells, platelets), *FCER1A* (myeloid dendritic cells).
```{r, fig.height=5, fig.width=7.2, out.width = '100%'}
GeneScatterPlot(sce,c("CD3D","CD79A","CST3","FCER1A"),
                dim.reduction.type = "umap",
                point.size = 0.3)
GeneScatterPlot(sce,c("CD3D","CD79A","CST3","FCER1A"),
                dim.reduction.type = "tsne",
                point.size = 0.3)

```


## Hierarchical clustering using the Ward's method

The $N \times p$ -dimensional consensus matrix is hierarchically clustered using the Ward's method.

```{r}
sce <- HierarchicalClustering(sce)
```


## Extracting a consensus clustering with $K$ clusters

After the hierarchical clustering, the user needs to define how many consensus clusters ($K$) to extract from the tree dendrogram. The `SelectKClusters` function enables extracting a consensus clustering with $K$ clusters. Please note that the clustering is **overwritten** every time the function is called.
```{r}
# Extract K=13 clusters.
sce <- SelectKClusters(sce,K=13)
```


Next, we use the `ClusteringScatterPlot` function to draw the t-SNE and UMAP transformations and color each cell according to the cluster labels.

```{r FigUMAP_TSNE, echo=TRUE, fig.height=10, fig.width=6, out.width = '100%'}
# Use plot_grid function from the cowplot R package to combine the two plots into one.
plot_grid(ClusteringScatterPlot(sce,
                                dim.reduction.type = "umap",
                                return.plot = T,
                                title = "UMAP",
                                show.legend=FALSE),
          ClusteringScatterPlot(sce,
                                dim.reduction.type = "tsne",
                                return.plot = T
                                ,title="t-SNE",
                                show.legend=FALSE),
          ncol = 1
)

```



## Identification of gene markers

The`ILoReg` R package provides functions for the identification of gene markers of clusters. This is accomplished by DE analysis, where gene expression levels of the cells from each cluster are compared against the rest of the cells. Currently, the only supported statistical test is the the Wilcoxon rank-sum test (aka Mann-Whitney U test). The *p*-values are corrected for multiple comparisons using the Bonferroni method. To accelerate the analysis, genes that are less likely to be DE can be filtered out prior to the statistical testing using multiple criteria.
```{r, eval = TRUE}

gene_markers <- FindAllGeneMarkers(sce,
                                   clustering.type = "manual",
                                   test = "wilcox",
                                   log2fc.threshold = 0.25,
                                   min.pct = 0.25,
                                   min.diff.pct = NULL,
                                   pseudocount.use = 1,
                                   min.cells.group = 3,
                                   return.thresh = 0.01,
                                   only.pos = TRUE,
                                   max.cells.per.cluster = NULL)

```


## Selecting top gene markers

Select top 10 and 1 gene markers based on the log2 fold-change and the Bonferroni adjusted p-value.
```{r, eval = TRUE}
top10_log2FC <- SelectTopGenes(gene_markers,
                               top.N = 10,
                               criterion.type = "log2FC",
                               reverse = FALSE)
top1_log2FC <- SelectTopGenes(gene_markers,
                              top.N = 1,
                              criterion.type = "log2FC",
                              reverse = FALSE)
top10_adj.p.value <- SelectTopGenes(gene_markers,
                                    top.N = 10,
                                    criterion.type = "adj.p.value",
                                    reverse = TRUE)
top1_adj.p.value <- SelectTopGenes(gene_markers,
                                   top.N = 1,
                                   criterion.type = "adj.p.value",
                                   reverse = TRUE)
```


Draw the t-SNE and UMAP transformations, highlighting expression levels of the top 1 gene markers based on the log2 fold-change.

```{r FigTop1Scatter, echo=TRUE, fig.height=21, fig.width=8, out.width = '100%', eval = TRUE}
GeneScatterPlot(sce,
                genes = unique(top1_log2FC$gene),
                dim.reduction.type = "tsne",
                point.size = 0.5,ncol=2)
```


## Gene marker heatmap

`GeneHeatmap` function enables visualizing gene markers in a heatmap, 
where cells and genes are grouped by the clustering.

```{r FigHM1, echo=TRUE, fig.height=15, fig.width=15, out.width = '100%', eval = FALSE}
GeneHeatmap(sce,
            clustering.type = "manual",
            gene.markers = top10_log2FC)

```


## Renaming clusters

`RenameAllClusters` enables renaming all clusters at once.

```{r}
sce <- RenameAllClusters(sce,
                         new.cluster.names = c("GZMK+/CD8+ T cells",
                                               "IGKC+ B cells",
                                               "Naive CD4+ T cells",
                                               "NK cells",
                                               "CD16+ monocytes",
                                               "CD8+ T cells",
                                               "CD14+ monocytes",
                                               "IGLC+ B cells",
                                               "Intermediate monocytes",
                                               "IGKC+/IGLC+ B cells",
                                               "Memory CD4+ T cells",
                                               "Naive CD8+ T cells",
                                               "Dendritic cells"))
```


Draw the gene heatmap again, but with the clusters renamed.

```{r FigHM2, echo=TRUE, fig.height=15, fig.width=15, out.width = '100%', eval = TRUE}
GeneHeatmap(sce,gene.markers = top10_log2FC)

```


## Violin plot visualization

`VlnPlot` enables visualization of gene expression grouped by clusters.

```{r FigVlnPlot, echo=TRUE, fig.height=5, fig.width=8, out.width = '100%'}
# Visualize CD3D: a marker of T cells
VlnPlot(sce,genes = c("CD3D"),return.plot = F,rotate.x.axis.labels = T)
```


## Saving results

Saving the results at the end of the workflow is recommended.

```{r}
saveRDS(sce,file = "~/pbmc3k_sce_final.rds")
```



# Additional functionality

`ILoReg` provides additional functionality for performing tasks, which are sometimes required in scRNA-seq data analysis.

## Estimating the optimal number of clusters

The optimal number of clusters can be estimated by calculating the average silhouette value across the cells for a set of clusterings within a range of different $K$ values (e.g. $[2,50]$). The clustering mathing to the highest average silhouette is saved to `clustering.optimal` slot. Therefore, the clustering acquired using the
`SelectKClusters` function is not overwritten.

```{r, fig.height=5, fig.width=7, out.width = '100%',fig.align = "center"}
sce <- CalculateSilhouetteInformation(sce,K.start = 2,K.end = 50)
SilhouetteCurve(sce,return.plot = F)
```


## Renaming one cluster

```{r FigRenaming2, echo=TRUE, fig.height=10, fig.width=12, out.width = '100%',eval = TRUE}
sce <- SelectKClusters(sce,K=20)
# Rename cluster 1 as A
sce <- RenameCluster(sce,old.cluster.name = 1,new.cluster.name = "A")
```

## Visualize with a custom annotation

```{r FigAnnotation, echo=TRUE, fig.height=5, fig.width=6, out.width = '100%',fig.align = "center",eval = TRUE}
# Select a clustering with K=20 clusters
sce <- SelectKClusters(sce,K=5)
# Generate a custom annotation with K=5 clusters and change the names to the five first alphabets.
custom_annotation <- plyr::mapvalues(metadata(sce)$iloreg$clustering.manual,c(1,2,3,4,5),LETTERS[1:5])
# Visualize the annotation
AnnotationScatterPlot(sce,
                      annotation = custom_annotation,
                      return.plot = F,
                      dim.reduction.type = "tsne",
                      show.legend = FALSE)
```


## Merging clusters

```{r, eval = TRUE}
# Merge clusters 3 and 4
sce <- SelectKClusters(sce,K=20)
sce <- MergeClusters(sce,clusters.to.merge  = c(3,4))
```



## Identification of differentially expressed genes between two arbitrary sets of clusters

```{r, eval = TRUE}
sce <- SelectKClusters(sce,K=13)
sce <- RenameAllClusters(sce,
                         new.cluster.names = c("GZMK+/CD8+ T cells",
                                               "IGKC+ B cells",
                                               "Naive CD4+ T cells",
                                               "NK cells",
                                               "CD16+ monocytes",
                                               "CD8+ T cells",
                                               "CD14+ monocytes",
                                               "IGLC+ B cells",
                                               "Intermediate monocytes",
                                               "IGKC+/IGLC+ B cells",
                                               "Memory CD4+ T cells",
                                               "Naive CD8+ T cells",
                                               "Dendritic cells"))
# Identify DE genes between naive and memory CD4+ T cells
GM_naive_memory_CD4 <- FindGeneMarkers(sce,
                                       clusters.1 = "Naive CD4+ T cells",
                                       clusters.2 = "Memory CD4+ T cells",
                                       logfc.threshold = 0.25,
                                       min.pct = 0.25,
                                       return.thresh = 0.01,
                                       only.pos = TRUE)


# Find gene markers for dendritic cells
GM_dendritic <- FindGeneMarkers(sce,
                                clusters.1 = "Dendritic cells",
                                logfc.threshold = 0.25,
                                min.pct = 0.25,
                                return.thresh = 0.01,
                                only.pos = TRUE)

```


# References 

1. Johannes Smolander, Sini Junttila, Mikko S Venäläinen, Laura L Elo. "ILoReg enables high-resolution cell population identification from single-cell RNA-seq data". BioRxiv (2020).
2. "3k PBMCs from a Healthy Donor". [10X Genomics](https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k).
3. "What is Cell Ranger?" [10X Genomics](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger).

# Contact information

If you have questions related to `ILoReg`, please contact us in [GitHub](https://gitlab.utu.fi/pajosm/iloreg). 

