---
title: "ILoReg package manual"
author: "Johannes Smolander"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{ILoReg package manual}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}
---

<style>
body {
text-align: justify}
</style>


```{r knitr-options, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
opts_chunk$set(fig.align = 'center', fig.width = 6, fig.height = 5, dev = 'png')
```


# Introduction to the method
`ILoReg` is a tool for high-resolution cell type identification from single-cell RNA-seq (scRNA-seq) data. High-resolution refers to the ability of `ILoReg` to identify subpopulations with subtle transcriptomic differences. In our study [1], we showed that `ILoReg` identitied, by both unsupervised clustering and visually, immune cell populations that other scRNA-seq data analysis pipelines were not able to find.

The figure below illustrates the workflows of `ILoReg` and a feature selection -based pipeline, which is commonly used by many scRNA-seq analysis pipelines, e.g. Seurat.

![*Figure: Analysis workflows of `ILoReg` and a feature-selection based approach*](figure.png){width=100%}

Unlike most scRNA-seq data analysis pipelines, `ILoReg` does not reduce the dimensionality of the gene expression matrix by feature selection. Instead, it performs a probabilistic feature extraction, in which the Iterative Clustering Projection (ICP) clustering algorithm is run *L* times, which yields *L* *k*-dimensional probability matrices that contain the new features. ICP is a novel clustering algorithm that iteratively seeks a clustering of size *k* that maximizes the adjusted Rand index (ARI) between the clustering $C$ and its projection $C'$ by L1-regularized logistic regression: $$\displaystyle \arg \max_C ARI(C,C')$$ The *L* probability matrices are then merged and transformed by the principal component analysis (PCA) into a lower dimensionality *p*. The final clustering step is performed using hierarhical clustering by the Ward's method, from which the user can efficiently (~1 s with 3,000 cells) select a clustering of size *K*. Two-dimensional visualization is supported using two popular nonlinear dimensionality reduction methods: *t*-Distributed Stochastic Neighbor Embedding (t-SNE) and Uniform Manifold Approximation and Projection (UMAP). Additionally, ILoReg provides user-friendly functions for the identification of differentially expressed (DE) genes and visualization of gene expression.


# Installation

The latest version of `ILoReg` can be downloaded from GitHub and installed by executing the following commands in the R console.


```{r eval = FALSE}
library(devtools)

creds = git2r::cred_ssh_key("~/../.ssh/id_rsa.pub",
                            "~/../.ssh/id_rsa")
devtools::install_git("gitlab@gitlab.utu.fi:pajosm/iloreg.git",
                      credentials = creds,ref = "eaf17d82")
```


# Example: Peripheral Blood Mononuclear Cells

In the following, we go through the different steps of `ILoReg`'s workflow and demonstrate it using a Peripheral Blood Mononuclear Cell (PBMC) dataset. The dataset (pbmc3k) can be downloaded from the following link: [GitHub](https://support.10xgenomics.com/single-cell-gene-expression/datasets)



## Setup a SingleCellExperiment object and prepare it for ILoReg analysis

The only required input for `ILoReg` is a normalized gene expression matrix with genes/features in rows and cells/samples in columns. The input can be of class *matrix*, *data.frame* or *dgCMatrix* and the matrix is then transformed into a sparse object of class *dgCMatrix*. Please note that the method has been designed to work with **sparse data**, i.e. with a high proportion of zero values. If, for example, the features of your dataset have been standardized, the run time and the memory usage of `ILoReg` are likely to be much higher.



```{r}
suppressMessages(library(ILoReg))
suppressMessages(library(SingleCellExperiment))
suppressMessages(library(cowplot))
sce <- SingleCellExperiment(assays = list(logcounts = pbmc3k_500))
sce <- PrepareILoReg(sce)
```


## Run ICP clustering algorithm *L* times

Running $L$ ICP runs in parallel is the most computationally demanding part of the pipeline.

In the following, we give a brief summary of the parameters.

* $k$: The number of initial clusters in ICP. Default $15$. A lower value generates less cluster probabilities. Along with decreasing $d$ , increasing $k$ is the easiest way to increase the complexity of the outcome, i.e. more subpopulations with subtle differences are formed.
* $C$: A positive real number that rules the trade-off between correctclassification and regularization: $$\displaystyle \min_w {\Vert w \Vert}_1 + C \sum_{i=1}^{l} \log (1+ e^{-y_i w^T w})$$ Default $0.3$. See [LIBLINEAR library](https://www.csie.ntu.edu.tw/~cjlin/liblinear/). Decreasing $C$ leads to more stringent feature selection, i.e. less genes are selected that are used to train the logistic regression classifier.
* $d$: A real number greater than $0$ and smaller than $1$ that determines how many cells $n$ are down- or oversampled from each cluster into the training data. ($d$ in $n=Nd/k$), where $N$ is the total number of cells. Default $0.3$. Decreasing $d$ below $0.2$ is not recommended due to the algorithm becoming unstable ($k$ starts to decrease during the iterations). In contrast, increasing $d$ leads to more dissimilar ICP runs and can be used to decrease the cell population diversity of the outcome
* $r$: A positive integer that denotes the maximum number of reiterations performed until the ICP algorithm stops. Default is $5$.
* $L$: The number of ICP runs. Default is $200$. 
* $type$: "L1" or "L2". "L2" denotes L2-regularization (Ridge regression), which was not investigated in our study. Default is "L1" (Lasso regresssion).
* $threads$: The number of threads to be used in parallel computing. Default is $0$: use all available threads but one. The parallelization can be disabled by setting value $1$. 


```{r eval = TRUE}
# ICP is stochastic. To obtain reproducible results, use set.seed().
set.seed(1)
# Run ICP L times. This is  the slowest step of the workflow and parallel processing can be used to greatly speed it up.
sce <- RunParallelICP(object = sce, k = 15,
                      d = 0.3, L = 30, 
                      r = 5, C = 0.3, 
                      reg.type = "L1", threads = 0)
# At this point, saving the results is recommended.
saveRDS(sce,file = "~/pbmc3k_500_iloreg.rds")
```


## Quality control

Next, we consider two quality control measures of ICP that can aid detecting issues with the `ILoReg` analysis.

The projection accuracy of ICP that denotes the adjusted Rand index (ARI) between the clustering and its  projection bylogistic regression at the final epoch of ICP. A projection accuracy $1$ would mean the classifier was able to predict the cluster membership of all cells correctly. As a general guideline, the average projection accuracy should be above $0.5$. A higher accuracy can be achieved using lower values of $k$, $C$ and higher values of $d$ and $r$.

The average similarity between ICP runs, measured by ARI. Since the $L$ probability matrices merged and transformed into a lower dimensionality by principal component analysis (PCA), transforming a set of correlated variables into a smaller set of uncorrelated variables, a some level of correlation among the probabilities is required to identify more cell subpopulations. A higher $d$ leads to a lower average ICP similarity and a smaller $k$ to a higher similarity. The relation of $C$ and $r$ with the metric is not unambiguous as with the projection accuracy of ICP.

```{r, fig.height=4, fig.width=9, out.width = '100%',fig.align = "center"}
# Draw violin plots of the projection accuracy of ICP, the number of epochs and the average similarity between ICP runs.
# Each data point represents an ICP run.
VisualizeQC(sce,return.plot = F)
```


## PCA transformation of the joint probability matrix

The $L$ probability matrices are merged into a joint probability matrix, which is then transformed into a lower dimensionality $p$ by PCA. At this point, the user can filter out ICP runs that achieved lower terminal projection accuracies.

```{r}
sce <- RunPCA(sce,p=50,scale = FALSE,threshold = 0)
```


PCA requires the user to select the number of principal components, for which we selected the default value $p=50$. The elbow plot is commonly used to seek a point of inflection, from which proximity the user selects the value of $p$. In this case it would be close to $p=10$.

```{r, fig.height=5, fig.width=7, out.width = '100%',fig.align = "center"}
PCAElbowPlot(sce)
```


## Nonlinear dimensionality reduction

To visualize the data in two-dimensional space, nonlinear dimensionality reduction is performed using either t-SNE or UMAP. The input for this step is the PCA-rorated data matrix.

```{r}
sce <- RunUMAP(sce)
sce <- RunTSNE(sce,perplexity=30)
```


## Hierarchical clustering using Ward's agglomeration

The PCA-rotated data matrix is clustered hierarchically using the Ward's method.

```{r}
sce <- HierarchicalClustering(sce)
```


## Gene expression visualization

Visualize expression of *CD3D* (T cells), *CD79A* (B cells), *CST3* (monocytes, dendritic cells, megakaryocytes), *FCER1A* (myeloid dendritic cells).
```{r, fig.height=5, fig.width=7.2, out.width = '100%'}
GeneScatterPlot(sce,c("CD3D","CD79A","CST3","FCER1A"),
                dim.reduction.type = "umap",
                point.size = 0.3)
GeneScatterPlot(sce,c("CD3D","CD79A","CST3","FCER1A"),
                dim.reduction.type = "tsne",
                point.size = 0.3)

```

## Selecting a clustering of size $K$

Manually select $K=40$ clusters from the dendrogram. This clustering is saved to *clustering.manual* slot and is overwritten every time the function is called.
```{r}
sce <- SelectKClusters(sce,K=13)
```


tSNE and UMAP transformations along with the optimal and manual clusterings.
```{r FigUMAP_TSNE, echo=TRUE, fig.height=5, fig.width=12, out.width = '100%'}
# Use plot_grid function from the cowplot R package to combine to plots into one.
plot_grid(ClusteringScatterPlot(sce,
                                dim.reduction.type = "umap",
                                return.plot = T,
                                title = "UMAP",
                                show.legend=FALSE),
          ClusteringScatterPlot(sce,
                                dim.reduction.type = "tsne",
                                return.plot = T
                                ,title="t-SNE",
                                show.legend=FALSE)
)

```



## Identification of gene markers

`ILoReg` provides functions for identifying gene markers for clusters. This is accomplished by DE analysis, where cells from each cluster are compared against the rest of the cells. The only statistical test supported at the moment is the the Wilcoxon rank-sum test (aka Mann-Whitney U test). The p-values are corrected for multiple comparisons using the Bonferroni method. 
```{r, eval = TRUE}

gene_markers <- FindAllGeneMarkers(sce,
                                   clustering.type = "manual",
                                   test = "wilcox",
                                   log2fc.threshold = 0.25,
                                   min.pct = 0.25,
                                   min.diff.pct = NULL,
                                   pseudocount.use = 1,
                                   min.cells.group = 3,
                                   return.thresh = 0.01,
                                   only.pos = TRUE,
                                   max.cells.per.cluster = NULL)

```


## Selecting top gene markers

Select top 10 and top 1 genes based on log2 fold-change and Bonferroni adjusted p-value.
```{r, eval = TRUE}
top10_log2FC <- SelectTopGenes(gene_markers,
                               top.N = 10,
                               criterion.type = "log2FC",
                               reverse = FALSE)
top1_log2FC <- SelectTopGenes(gene_markers,
                              top.N = 1,
                              criterion.type = "log2FC",
                              reverse = FALSE)
top10_adj.p.value <- SelectTopGenes(gene_markers,
                                    top.N = 10,
                                    criterion.type = "adj.p.value",
                                    reverse = TRUE)
top1_adj.p.value <- SelectTopGenes(gene_markers,
                                   top.N = 1,
                                   criterion.type = "adj.p.value",
                                   reverse = TRUE)
```



## Gene expression scatter plot

Visualize gene expression levels of cells over t-SNE or UMAP visualization.

```{r FigTop1Scatter, echo=TRUE, fig.height=21, fig.width=8, out.width = '100%', eval = TRUE}
GeneScatterPlot(sce,
                genes = unique(top1_log2FC$gene),
                dim.reduction.type = "tsne",
                point.size = 0.5,ncol=2)
```


## Gene marker heatmap

GeneHeatmap function enables visualizing gene markers in a heatmap, where cells and genes are grouped by the clustering.

```{r FigHM1, echo=TRUE, fig.height=15, fig.width=15, out.width = '100%', eval = FALSE}
GeneHeatmap(sce,
            clustering.type = "manual",
            gene.markers = top10_log2FC)

```


## Rename clusters

```{r}
sce <- RenameAllClusters(sce,
                         new.cluster.names = c("GZMK+/CD8+ T cells",
                                               "IGKC+ B cells",
                                               "Naive CD4+ T cells",
                                               "NK cells",
                                               "CD16+ monocytes",
                                               "CD8+ T cells",
                                               "CD14+ monocytes",
                                               "IGLC+ B cells",
                                               "Intermediate monocytes",
                                               "IGKC+/IGLC+ B cells",
                                               "Memory CD4+ T cells",
                                               "Naive CD8+ T cells",
                                               "Dendritic cells"))
```


## Gene marker heatmap with renamed clusters

GeneHeatmap function enables visualizing gene markers in a heatmap, where cells and genes are grouped by the clustering.

```{r FigHM2, echo=TRUE, fig.height=15, fig.width=15, out.width = '100%', eval = TRUE}
GeneHeatmap(sce,clustering.type = "manual",gene.markers = top10_log2FC)

```


## Visualization of gene expression grouped by clusters with violin plots

Violin plots provide a nice way to visualize gene expression across clusters. 

```{r FigVlnPlot, echo=TRUE, fig.height=5, fig.width=8, out.width = '100%'}
VlnPlot(sce,clustering.type = "manual",genes = c("CD3D"),return.plot = F,rotate.x.axis.labels = T)
```



## Saving results

Saving the results at the end of the workflow is recommended.

```{r}
saveRDS(sce,file = "~/pbmc3k_sce_final.rds")
```



# Additional functionality

`ILoReg` provides additional functionality for performing tasks, which are commonly required in scRNA-seq data analysis.

## Estimating optimal number of clusters

Estimation of the optimal number of clusters is done by calculating the average silhouette value across the cells for clusterings with different $K$ values in a range (e.g. $[2,50]$). The clustering acquired using $K$ with the highest average silhouette is saved to *clustering.optimal* slot.

```{r, fig.height=5, fig.width=7, out.width = '100%',fig.align = "center"}
sce <- CalculateSilhouetteInformation(sce,K.start = 2,K.end = 50)
SilhouetteCurve(sce,return.plot = F)
```


## Rename one cluster with RenameCluster function.
```{r FigRenaming2, echo=TRUE, fig.height=10, fig.width=12, out.width = '100%',eval = FALSE}
sce <- SelectKClusters(sce,K=20)
tsne_before <- ClusteringScatterPlot(sce,dim.reduction.type = "tsne",title = "Before renaming",show.legend = FALSE,return.plot = TRUE)
umap_before <- ClusteringScatterPlot(sce,dim.reduction.type = "umap",title = "Before renaming",show.legend = FALSE,return.plot = TRUE)
sce <- RenameCluster(sce,old.cluster.name = 1,new.cluster.name = "A")
tsne_after <- ClusteringScatterPlot(sce,dim.reduction.type = "tsne",title = "After renaming",show.legend = FALSE,return.plot = TRUE)
umap_after <- ClusteringScatterPlot(sce,dim.reduction.type = "umap",title = "After renaming",show.legend = FALSE,return.plot = TRUE)
```

## Visualize with custom cluster labels

```{r FigAnnotation, echo=TRUE, fig.height=5, fig.width=6, out.width = '100%',fig.align = "center",eval = TRUE}
# Select a clustering with K=20 clusters
sce <- SelectKClusters(sce,K=5)
# Generate a random annotation, in which cell has 90% change of having the same cluster as in ILoReg's clustering
custom_annotation <- plyr::mapvalues(metadata(sce)$iloreg$clustering.manual,c(1,2,3,4,5),LETTERS[1:5])
# Visualize the annotation
AnnotationScatterPlot(sce,annotation = custom_annotation,return.plot = F,dim.reduction.type = "tsne",show.legend=FALSE)
```


## Merging clusters

```{r, eval = TRUE}
# Merge clusters 3 and 4
sce <- SelectKClusters(sce,K=20)
sce <- MergeClusters(sce,clusters.to.merge  = c(3,4))
```



## Identification of differentially expressed genes between two arbitrary sets of clusters

```{r, eval = TRUE}
sce <- SelectKClusters(sce,K=13)
sce <- RenameAllClusters(sce,
                         new.cluster.names = c("GZMK+/CD8+ T cells",
                                               "IGKC+ B cells",
                                               "Naive CD4+ T cells",
                                               "NK cells",
                                               "CD16+ monocytes",
                                               "CD8+ T cells",
                                               "CD14+ monocytes",
                                               "IGLC+ B cells",
                                               "Intermediate monocytes",
                                               "IGKC+/IGLC+ B cells",
                                               "Memory CD4+ T cells",
                                               "Naive CD8+ T cells",
                                               "Dendritic cells"))
# Identify DE genes between naive and memory CD4+ T cells
GM_naive_memory_CD4 <- FindGeneMarkers(sce,
                                       clusters.1 = "Naive CD4+ T cells",
                                       clusters.2 = "Memory CD4+ T cells",
                                       logfc.threshold = 0.25,
                                       min.pct = 0.25,
                                       return.thresh = 0.01,
                                       only.pos = TRUE)


# Find gene markers for dendritic cells
GM_dendritic <- FindGeneMarkers(sce,
                                clusters.1 = "Dendritic cells",
                                logfc.threshold = 0.25,
                                min.pct = 0.25,
                                return.thresh = 0.01,
                                only.pos = TRUE)

```


# References 

1. Johannes Smolander, Sini Junttila, Mikko S Venäläinen, Laura L Elo. "ILoReg enables high-resolution cell population identification from single-cell RNA-seq data". BioRxiv (2020).

# Contact information

If you find bugs from `ILoReg` or have suggestions on how to improve our pipeline, please contact us in [GitHub](https://gitlab.utu.fi/pajosm/iloreg). 

